### 1. 科学计算与 workflow 调度

#### 1.1 什么是科学计算

震波的分析进行石油勘探。在生命科学领域，科学家们通过对人类基因组排序来学习人类进化的规律等。科学计算给这些“分析”和“学习”提供了理论依据和方法。

科学计算需要处理的数据量巨大。比如CERN的大型对撞机平均每年都会产生millionsof gigabytes 的数据 (source: http://home.cern/about)。这些数据需要被收集，管理以及反复处理，以期从中发现物质的组成和宇宙的起源。这对数据格式、数据存储等的研究提出了很大的挑战。也算是大数据的一个典型应用。

科学计算涉及的计算一般也十分复杂。比如刚提到的石油勘探，为了能从地震波数据中发现有用信息，需要的计算量可以达到10+e22次浮点运算(source: http://blog.csdn.net/zhaogaishan/article/details/4813435)。即使假设我们能fullyutilize天河II的实际峰值运算能力，也需要82小时才能完成一次上述运算。并且，这一计算量会随着数据量的增长进一步增加。也就是说，我们每做一次数据分析，需要等上好几天才能看到分析结果，这显然不是我们希望的 [1]。

#### 1.2 什么是 Scientific Workflows

在科学计算中，我们会执行一些scientific simulation code 来生成数据，然后执行一些dataanalysis code 来分析数据。在这两个步骤之间，我们通常还会执行一些glue scripts (e.g., data formatconversion) 来自动化这一过程。这些具有数据dependency的codes通常被model成scientific workflow，每个code节点都是workflow中的一个task。我们利用scientific workflow这一模型来**automate** and **optimize**这些dependent tasks的执行 [1]。

#### 1.3 什么是 WfMS

我们需要设计专门的workflow management systems (WfMS)来运行和管理workflows[6] 。现有的WfMS分别具有一些自己的特点，而用户可以根据自己的需求从中选择最合适自己的系统来用。例如，Pegasus系统允许用户用XML-basedlanguage来描述workflow，并提供fault recovery 和dataprovenance information等功能。而Kepler系统提供图形界面帮助用户“画出”workflow结构，并且可以很容易将其embedded 到 webportal中。不同的WfMS系统的存在虽然给用户提供了更多的选择，但也增加了软件管理的复杂度。目前的一个研究趋势是，结合现在各种并行计算模型和open-sourced分布式系统，讨论是否能够利用现有系统来运行和管理workflow。其优点是很明显的，既能减少开发时间，又可以增加系统兼容性 [1]。

#### 1.4 Scientific Workflows 的优化

在实现了workflow的自动执行后，我们还需要去优化其执行过程，目前一般是通过优化workflowtasks的调度来实现的。对于scientificworkflow的优化一般涉及以下优化目标: 1) the performance of the workflows; 2)resource utilization during workflow executions; or 3) the operational cost forexecuting the workflows. 简单来说，用户们或者是希望他们的科学仿真和数据分析程序执行的越快越好（一般是科学家们），或者是希望计算平台的资源能够被高效地利用（一般是计算平台的管理者）。我们组在workflow的优化问题上也做过一些工作[1][2] [3] 。我们提出的Transformation-based Optimization Framework (ToF) [3]将workflowoptimization operations进行了抽象，并利用这些抽象了的优化操作给不同结构、类型的workflow提供统一的优化。我们的另一篇工作Deco[2] 考虑到了不同workflow优化问题的用户和优化目标的多样性，提出利用declarativelanguage让用户去描述其优化目标，并设计了一个generalized optimization engine来提供相应的优化solution。Workflow的优化还有很多待解决的问题需要我们去探讨，例如HPC上多用户多workflow之间的资源共享问题等 [1]。

### 1.5 应用前景

* 比较火，国际会议热点，HPC，HPC投资


* 传统科学计算
* 大数据（分析、推荐）
* 机器学习

### 2. 研究基础与现状

#### 2.1 IaaS Workflows 调度算法分类

**2.1.1 应用模式**

调度算法的应用模式可以按照 Workflow 的多重性分为单工作流、一个工作流的多个实例和多工作流。

* 单工作流：单工作流被广泛应用于网格计算并且也是在云计算环境下最普遍的应用，这类调度算法专注于调度一个用户的一个工作流（DAG）的执行，既在 QoS 约束下优化花费。
* 一个工作流的多个实例：许多科学计算应用（e.g. balabala）将多个具有相同结构但是不同大小的工作流组合在一起组成一个合体，这类调度算法需要专注于一个合体整体的调度 QoS 约束而不是仅仅一个工作流。合体中 workflows 的数量是已知的，调度算法可以使用这些信息子在运行中来调整调度策略。
* 多工作流：多工作流与一个工作流的多个实例类似，但是多工作流中的工作流之间没有必要的联系和相似的结构，它们的 QoS 约束也没有联系，并且工作流的数量事先是不知道的，并且随时都有新的工作流加入到处理队列中。

**2.1.2 调度模式**

调度模型可以从以下四个方面进行分类：

* Task-VM 映射的动态性
  * 静态
  * 动态
  * 混合
    * 运行时调整
    * 静态子工作流
* 资源分配策略
  * 静态分配
    * 静态 VM 池
    * 弹性 VM 池
      * 任务调度
  * 动态分配
    * 弹性 VM 池
      * 约束要求
      * 性能指标
* 调度目标
  * 花费
    * 有预算
    * 最小化
  * 时间
    * 有截止期限
    * 最小化
  * 负载最大化
  * VM 利用率最大化
  * 能量消耗最小化
  * 可靠性感知
  * 安全感知
* 优化策略
  * 最优
  * 近似最优
    * 启发式
    * 元启发
    * 混合
      * 启发元启发
      * 启发最优



**静态 Task-VM 映射**：Task-VM 映射被实现规划好，并且运行时不允许更改。这种调度模式会导致多米诺效应：一个微小的失误就可以引起整个工作流的执行失败（达不到 QoS 要求）。一些算法使用了一些策略（e.g. 运行时预测，概率 QoS，资源性能变化模型等）来提升静态映射的适应性。静态映射的优点在于可以使用全局优化来获得工作流级别的高质量调度计划。

**动态 Task-VM 映射**：这种映射方式是动态的，映射策略基于系统当前状态和工作流的执行情况，这种适应能力使得它能在变化的环境中调整调度策略并到达用户的要求，这种高适应性使它适用于云环境下，但是任务级别的可视性影响了调度算法的优化性，伤害了找到高质量调度算法的能力。

**混合映射**：有些算法对静态映射和动态映射效果进行了折中，既保留了一定的优化性又具有一定的动态性。混合映射可以分为两类，运行时调度和静态子工作流。运行时调度首先根据目前的状态生成一个静态的映射方式，算法会选择更新一个任务的调度或者整个调度计划，更新一个任务会会更快，但是对以后工作流执行产生的影响将是不可预估的，更新整个工作流执行计划会导致大量的时间延迟和计算资源超载。静态子工作流根据系统目前的状况在每一轮调度中将任务的子集调度到适合的资源上，这种映射的缺点是静态指派任务，尽管在较小的程度上，会导致无法预测的延迟。

**静态 VM 池**：静态VM池一旦被确定下来，池内的资源会被租借，并且一直保持激活状态直到工作流执行结束。这种策略的优点在于调度算法在调度过程中只关心 Task-VM 之间的映射，资源分配和回收的延迟得到了很好的分摊，并且可以得到很好的管理，但是这种方式没有充分利用到云资源的伸缩性和计费模式，造成预算超标， 成本效益低，违背用户在经济方面的 QoS 要求。

**伸缩 VM 池**：这种策略使得调度算法可以在工作流的执行过程中动态地变更资源数量（VM的类型和数量），算法可以根据任务的约束条件（e.g. time deadline）或者系统的整体性能指标（e.g. VM利用率，吞吐量）来决定是否增添或者释放资源。

**调度目标**：大多数调度算法会把花费作为调度的目标，除了花费外，大多数算法还会考虑一些性能指标（如，运行时间，负载，利用率等）。一些经典的算法还考虑到了能量消耗，可靠性和安全性等因素。

**优化策略**：工作流的调度问题是NP完全问题，优化策略可以分为最优化和近似最优，即使很小的问题规模找到最优的调度计划也是花费巨大的，并且最优的定义受调度器对于系统状态的和资源需求以及人物属性的假设。

**最优解**：有许多方法可以达到最优解，[laba] 提出了4中寻找最优解的策略：解空间遍历，图论，数学规划和数学模型。在被调研的算法中，混合线性规划被用于寻找工作流级别的最优解。

**近似最优解**：大多数算法会通过寻找近似最优解来降低计算复杂度，寻找近似最优解的方法可以划分为：启发式，元启发式和混合式。启发式算法是一系列用于寻找某个特定问题最优解的规则。它的优点在于性能优秀，够在较短的时间内找到合适的解决方案，并且比元启发算法更容易实现和更容易预测。启发式算法通常是为解决某个特定的问题而设计的，那么元启发式算法就是为解决一系列优化问题而设计的[]。它是一种比启发式算法更高一层的策略，与启发式算法相比，元启发式算法的计算复杂度会更高，意味着花费的时间更多，但是在有指导的搜索下它会找到更多的令人满意的解决方案。混合方法对两种类型的算法进行折中，它使用元启发算法来优化工作流中的任务，同时寻找一些小规模的任务并使用启发式算法进行优化，这样可以得到比启发式算法更好的优化程度和比元启发算法更好的计算复杂度。

**2.1.3 资源模式**

* 提供商
  * VM租赁模型
    * 有限VM
    * 无限VM
  * VM类型一致性
    * 单一VM类型
    * 多VM类型
  * 部署模型
    * 提供商
      * 单一
      * 多
    * 数据中心
      * 单
      * 多
* 存储和网络
  * 数据共享方式
    * P2P
    * 共享存储
  * 数据传输花费感知
  * 存储花费感知
* 虚拟机
  * VM 计价模式
    * 动态计价
    * 静态计价
    * 基于描述
    * 时间单元
  * VM 延迟
    * 分配资源延迟
    * 回收资源延迟
  * VM 核心花费
    * 单核
    * 多核

#### 2.2 研究现状

**2.2.1 多截止期限约束下的 Scientific Workflows 调度算法**

Malawski 等人在 [] 中提出了一用于在有截止时间约束条件下的优化花费的数学模型，它使用的范围是多云供应商，每个供应商提供有限的异构的虚拟机，并且使用了全局存储服务来共享中间文件，他们使用了混合线性规划来处理进行任务优化和数据存储。他们实现了两个版本，一个是调度粗粒度的工作流任务（执行时间超过一个小时），一个是细粒度工作流认为（执行时间小于一个小时）。混合线性规划利用了大规模科学计算工作流的特性的优势：他们以连续的层次依赖为组织。基于这个特性，作者按照任务的计算花费和输入输出来将任务划分为多个不同的层次，然后根据这些层次来进行调度而不是按照单个的任务，这样可以大大地减少混合线性规划的复杂度。另一个可以减少混合线性规划的设计选择是关闭不同层次间的VM之间的资源共享，但是这种假设会导致系统资源利用率低并且对于某些数据密集型应用导致花费过高。同时在考虑在截止时间之前完成任务执行时，这种算法过度依赖于准确的运行时数据（计算，存储，数据传输时间）

**2.2.2 SABA**

Balbal 等人在 [] 中提出了一种安全感知和预算感知的算法，该算法适用于混合云环境，作者定义了不可移动数据集和可移动数据集的概念。可移动的数据集没有安全方面的约束，因此可以再两个数据中心之间传输和复制。不可移动的数据集则受限于一个数据集中由于安全和预算的限制。算法由三步构成：1. 首先是聚类和优先级划分阶段，基于工作流的不可移动数据集将数据和任务指派给指定的数据中心。2. 第二步按照性能花费比率将任务静态指派到VM。3. 最后，中间数据将在运行时动态移动到准备执行任务的VM上。除了考虑到数据的安全性，SABA也考虑到了可能需要的安全服务类似，认证，授权，完整性和保密性，并且还有使用这些服务的时间花费和经济花费，SABA也考虑到了I/O、带宽和内存能力。文中虚拟机的花费是由虚拟机实际使用时间计算得到的，但是他们没有考虑到由云服务提供商设置的按时计价模式（amazone按小时收费，aruze 10min），该算法应用在实际中会造成实际花费比预期过大。

**2.2.3 基于 PSO 的资源分配和调度算法**

Rodriguez 和 Buyya 等人在 [] 中提出了一种静态的，以最小花费为优化目标的，具有截止时间约束的算法，他们的算法中考虑到了弹性资源费配和异构的计算资源和VM性能变化。他们将资源的分配和任务的调度相结合构成了一个PSO的问题，算法的输出是一个近似最优的决策：要租用的VM数量和类型，租借的时间和任务资源映射。作者还引入了一个在运行时评估性能下降的手段，并以此来改变资源分配和任务调度策略，这很好地弥补了静态调度算法比较弱的适应性，能有效地捕捉到环境的变化并作出回应。但是计算复杂度随着工作流中的任务数量或者服务提供商提供的VM类型增加而剧烈上升。

**2.2.4 MOHEFT**

Durillo 和 Prodan 等人在 [] 中提出了一种多优化目标的异构试用的最早完成时间算法（MOHEFT），这种算法是经典DAG调度算法 HEFT 的一个扩展。基于启发式的算法计算出一系列基于帕累托的解决方案，用户可以选择最适合的一个。与 HEFT 每一步建立一个不同，MOHEFT 在每一步都并行地建立一些中间工作流调度或者解决方案。这种算法原生适用于解决数量和类型目标的优化，但是在类似亚马逊商业云上运行工作流应用时，使用这种调度算法会使完成时间和花费也会得到优化。最后，如原文中作者所说，大多数计算帕累托前沿的解决方案使用遗传算法，遗传算法会导致较大的计算时间，并且计算时间无法估计，而 MOHEFT 的时间复杂度近似为O（n*m），你是任务数，m是资源数。

**2.2.5 资源竞拍下的容错调度算法**

Poola 等人在 [] 中提出了一种使用两种云实例的调度算法，按需和竞价。作为为数不多的探究VM动态定价的算法，他们考虑到了了一种竞价VM类型（最便宜了类型）和多种按需类型。作者还定义了最后按需时间的概念（LTO），它决定了算法需要把实例从竞价模式迁移到按需模式的最后时间。作者还提出额一种VM竞价策略：竞价的开始价格开始接近于初始竞价并且随着任务的执行价格会接近于按需节价格，接着LTO时间到达。这种策略降低了出价过高接近于LTO并且增加了达到截止时间要求的概率。这种算法充分利用了竞价资源的灵活性，大大降低了运行的花费，但是这种优势会被减少因为文中只考虑到了竞争最便宜的VM，如果截止时间约束比较严格，那么最便宜的VM在LTO到达之前不会被分配任何任务，所有的任务都被在按需VM上执行，另一个缺点是这种算法依赖于检查点技术，有许多遗留的科学计算应用并没有检查点检测技术，并且为了达到这个目的而对数据的排序会大大增加基础设施的花费。

**2.2.6 IC-PCP**

Abalab 在 [] 中提出了一种 IaaS 云局部关键路径算法（IC-PCP）来优化总体执行花费同时达到截止时间要求。算法以寻找一组任务为开始（局部关键路径PCPs），与工作流中的每个退出节点又换，接着每条路径上的所有任务被分配至同一个VM，并且优先分配至一个能达到最迟完成时间要求的已经租借的实例。如果不能达到目的，这个任务就会被分配到一个新租借的最便宜的能满足要求的VM实例上。PCP被递归地调用来识别和重复处理指导工作流中的所有任务被调度。IC-PCP的缺点是没有考虑到VM分配的延迟和资源性能的波动，这是得这种算法对CPU性能下降较为敏感，导致了由于不可预期的延迟而错过了截止时间。这种算法采用了静态和基于启发式的算法，因此适用有效地于找到高质量的调度计划，适合于调度具有数千个任务的大规模的工作流，另外该算法也适用于调度那些低CPU需求的工作流从而降低性能波动（随机事件）对最后的调度效果的影响。

**2.2.7 EIPR**

Calheiros 和 Buyya 在文献  [] 中提出了一种增强的具有复制的IC-PCP算法（EIPR），该算法使用已分配的资源（VM）的空闲时间和预算的盈余来复制某些任务来减缓性能下降带来的影响从而完成截止时间的约束。算法首先决定要租借资源数量和类型和任务在这些资源上的顺序和位置，这一步使用了IC-PCP的主启发式算法思想。第二步决定VM的开始和停止时间，EIPR从任务的开始结束时间和数据传输时间两个方面考虑VM租赁开始结束时间。最后，算法复制一些任务的执行在已经激活的VM的空闲时隙或者利用预算的盈余来租借新的资源来运行这些任务。算法按照一定的优先来选取复制任务，首先是可用时间不多，接着是长时间执行任务，最后是最后一个任务有大量子任务的。尽管是一个静态的算法，但是EIPR成功地通过探索弹性和云的计价模式降低了差的和变化的资源。可以保证获得高质量的度奥都算法同时具有良好的鲁棒性针对不稳定的环境延迟。但是，复制任务的完成不一定会成功，因为任务的实质性时间与计费时间相似，这是因为有较少机会的时隙可供使用，

**2.2.8 2层SLA约束下的workflow调度算法**

**2.2.9 PBTS**

**2.2.10 SPSS 和 DPDS**

**2.2.11 SPSS-ED 和 SPSS-EB**

**2.2.12 Dyna**

**2.2.13 SCS**

### 3. 结论

### 4. 参考

[1] Amelie Chi Zhou, http://blog.sciencenet.cn/blog-3224193-1009723.html