\documentclass[10pt,journal,compsoc]{IEEEtran}



% *** CITATION PACKAGES ***
%
\ifCLASSOPTIONcompsoc
  % The IEEE Computer Society needs nocompress option
  % requires cite.sty v4.0 or later (November 2003)
  \usepackage[nocompress]{cite}
\else
  % normal IEEE
  \usepackage{cite}
\fi

% *** GRAPHICS RELATED PACKAGES ***
%
\ifCLASSINFOpdf
 
\else
  
\fi

\ifCLASSOPTIONcompsoc \usepackage[caption=false,font=normalsize,labelfon
t=sf,textfont=sf]{subfig}
\else
\usepackage[caption=false,font=footnotesize]{subfi g}
\fi


\usepackage{graphicx}
\usepackage{algorithmic}
\usepackage{algorithm}
\renewcommand{\algorithmicrequire}{\textbf{Input:}} 
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\usepackage{amsfonts,amssymb}

% \usepackage{cases}
\usepackage{amsmath}
\usepackage[overload]{empheq}
\newcommand{\for}{\text{for }}

\newcommand\MYhyperrefoptions{bookmarks=true,bookmarksnumbered=true,
pdfpagemode={UseOutlines},plainpages=false,pdfpagelabels=true,
colorlinks=true,linkcolor={black},citecolor={black},urlcolor={black},
pdftitle={Bare Demo of IEEEtran.cls for Computer Society Journals},%<!CHANGE!
pdfsubject={Typesetting},%<!CHANGE!
pdfauthor={Michael D. Shell},%<!CHANGE!
pdfkeywords={Computer Society, IEEEtran, journal, LaTeX, paper,
             template}}%<^!CHANGE!

\hyphenation{op-tical net-works semi-conduc-tor}

\begin{document}

\title{QoS-Oriented Mobile Service Composition Over Oppotunistic Networks}

\author{QingLan~Peng,~\IEEEmembership{Member,~IEEE,}
        ChunRong~Wu,~\IEEEmembership{Member,~IEEE,}
        and~Jane~Doe,~\IEEEmembership{Life~Fellow,~IEEE}% <-this % stops a space

\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem M. Shell was with the Department
of Electrical and Computer Engineering, Georgia Institute of Technology, Atlanta,
GA, 30332.\protect\\
% note need leading \protect in front of \\ to get a newline within \thanks as
% \\ is fragile and will error, could use \hfil\break instead.
E-mail: see http://www.michaelshell.org/contact.html
\IEEEcompsocthanksitem J. Doe and J. Doe are with Anonymous University.}% <-this % stops a space

\thanks{Manuscript received April 19, 2005; revised August 26, 2015.}}



% The paper headers
\markboth{Journal of \LaTeX\ Class Files,~Vol.~14, No.~8, August~2015}%
{Shell \MakeLowercase{\textit{et al.}}: Bare Advanced Demo of IEEEtran.cls for IEEE Computer Society Journals}

\IEEEtitleabstractindextext{%
\begin{abstract}
Mobile service computing is a promising paradigm capable of utilizing the pervasive computing resources around us. Mobile users can exploit nearby mobile service to boost their computing power and therefore overcome the limitations of their own resources. In this paper we look into the realization of self-organized mobile service composition on opportunistic networks, and propose a framework named mobile service opportunistic network(MSON) to address the dynamic and mobile characteristic in mobile environment and then formulated the service composition over MSON to an optimal problem and utilize improved Krill-Herd algorithm(IHK) to solve it. To evaluate the effectiveness and efficiency of our approach, we obtain experimental performance data through a real-world opportunistic network. The experimental results demonstrate that our approach can obtain superior solutions as compared with current standard composition methods in mobile environments. It can yield near-optimal solutions and has a nearly linear complexity with respect to a problem size.

\end{abstract}

% Note that keywords are not normally used for peerreview papers.
\begin{IEEEkeywords}
Mobile Computing, Mobile opportunistic network, Mobile Service Composition, Service-Oriented Architecture.
\end{IEEEkeywords}}


% make the title area
\maketitle



\IEEEdisplaynontitleabstractindextext

\IEEEpeerreviewmaketitle


\ifCLASSOPTIONcompsoc
\IEEEraisesectionheading{\section{Introduction}\label{sec:introduction}}
\else
\section{Introduction}
\label{sec:introduction}
\fi


\IEEEPARstart{R}{ecent years} have witnessed the rapid development of mobile devices and mobile communication technology. 
mobile devices has already surpassed stationary Internet hosts in numbers. Web services are no longer limited to traditional stationary platforms and they can be more flexible and pervasive. The hardware of mobile devices will continue to make breakthroughs on extending the capabilities of mobile devices in terms of computational power, RAM, storage capacity, and so on \cite{Deng2017}. The huge potential of mobile technology brings a great opportunity to traditional service computing in the mobile environment. As a result, the global interest of mobile service is on the rise and both academia and industry are inspired to pave the way for mobile service provisioning \cite{dinh2013survey,hu2014multidimensional}.

While mobile device have powerful computing and communication capabilities now, the resources-intensive services, however, drain out the energy of the device much faster than before. 
To achieve the goal of reducing mobile device energy consumption, we propose a QoS-oriented mobile service composition approach in this paper, where a mobile user in mobile opportunistic network can combine and exploit nearby devices' resources to boost their computing power and therefore overcome the limitations of their own resources. As shown in fig.1, this architecture can reduce communication energy consumption and avoid the extreme centralization of traditional mobile cloud computing \cite{Giordano2011}. Its main rationality is three-fold. First, opportunistic user encounters are prevalent and sufficient in daily life \cite{liu2013exploring}, which offers plenty of opportunities to exploit nearby mobile worker for task solving \cite{chang2015progressive,heimerl2012communitysourcing,agapie2015crowdsourcing}. Second, many mobile tasks require huge computational resources or data transfer (e.g., Tensorflow on mobile, Photoshop on mobile, Online video), for energy consumption and cost perspective, nearby mobile service provider are more adept at executing these tasks than the online workers, because this paradigm can reduce data transfer over cellular network which consume more energy than device to device (D2D) communications such as Bluetooth, WiFi and NFC \cite{Balani}. Third, D2D communications are promising to replenish traditional cellular communications in terms of user throughput increase, cellular traffic reduction and network coverage extension, in this way, users can get better quality of service and save communication fee\cite{asadi2014survey}. In a word, this framework shares the similar spirit with the emerging paradigm “cyber foraging” over opportunistic networks, such that mobile users opportunistically exploit nearby device resources to facilitate their computational task processing \cite{shi2012serendipity,li2014can,zhang2015offloading}.

\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./img/pic1.pdf}
\caption{Opportunistic computing}
\label{fig_opportunistic}
\end{figure}

To address the aforementioned challenges and concerns, we propose a new approach for mobile service composition over opportunistic network. The main contributions are:

1) We propose a framework (mobile service opportunistic network MSON) to address the problem of service provision in the mobile encounter environment where both service requesters and providers are nonstationary. In such environment, mobile user can invoke service exposed by nearby mobile devices through D2D links.

2) For MSON, we propose a mobile service QoS model for service provision which consider mobile service availability as an important QoS attribute to capture user's mobility behavior.

3) Based on MSON and the proposed mobile service QoS model, we transfer the mobile service composition problem to an optimization problem and use the Krill-Herd algorithm (KH) to solve it. A series of evaluations have been conduct to validate the optimality and scalability of our algorithm, and it shows our algorithm can get approximately optimal solution and better performance than other standard composition approaches. 

The remainder of this paper is structured as follows. Section II describe the MSON framework and its application scenario. Section III introduces the mobile service composition model. The approach to make service compositions is presented in Section IV. Section V presents experiments and evaluations. Section VI reviews the related work. Section VI concludes this paper.

\section{MSON AND APPLICATION SCENARIO}

\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./img/pic2.pdf}
\caption{Mobile service opportunistic network}
\label{fig_mson}
\end{figure}

In this section, we first introduce the characteristics of mobile service opportunistic network (MSON), then an example is presented to illustrate its application scenario.

MSON has three main characteristics:

1) Locality: An MSON is not established through the stable Internet, it do not consider user mobility a problem but as an opportunity to exploit. Mobile user in MSON can perceive nearby service and establish self-organized local communication network within transmission distance.

2) Mobility: Services requesters and providers are not fixed at the same location, and they are mobile when invoking or provisioning a mobile service.

3) Nondeterminacy: MSON participants are not stationary, one node can enter or leave the data transmission range of other nodes at any time. 

Fig.2 illustrates the working procedure of the mobile service provision over opportunistic network. In an opportunistic network scenario, a mobile service requester can perceive mobile service exposed by nearby devices through D2D links and launch a mobile composition request. A composer can be implemented and deployed on the requester's mobile device, which is in charge of discovering available mobile services nearby, selecting appropriate concrete service, and composing multiple services. During the execution of mobile service compositions, all concrete services interact with the composer directly \cite{Deng2017}.

Note that, our framework only considers one-hop mechanism for both service requester and provider, since some realistic dataset analyses reveal that users' one-hop neighbors are sufficient, compared with multi-hop mechanisms in existing researches \cite{chang2015progressive,karaliopoulos2015user,han2016competition,tuncay2013participant,wu2013homing,jiang2016exploiting,liu2013exploring}, D2D communication which hops are larger than two would incur long delay \cite{li2014can},  this one-hop feature can lower the network overhead (e.g., no need to transfer a large volume of task contents hop by hop) and ensure framework choose only local relatively reliable service. 

We use an example to illustrate the related features of service provision over MSON. Assume a mobile user Mike just complete his tour and now he is on the subway to airport. Now he wants to edit some videos he recorded and add some effects and share these video clips with his friends. But due to mobile devices' limited battery, if he edit videos in his own mobile device, his mobile phone will run out of energy before he reach the destination. As one option, he can upload original videos to cloud and use cloud service to get all things done, but offloading quest into cloud will result in heavy cellular traffic, that means expensive communication fee and high energy consumption. If Mike participate in MSON and several video processing services is provided by some nearby mobile devices, Mike can invoke such mobile services on nearby mobile devices through D2D communication techniques. If these services cannot meet his requirement, several services can be composed. Due to users' mobility, the availability of service to Mike can vary, invoking mobile services provided by other users may face new challenges that traditional composition methods cannot handle. Thus, a mobile service composition model which can capture mobile services' availability need to be proposed, we will discuss mobile service availability in next section \cite{Deng2016-2}.


\section{MOBILE SERVICE COMPOSITION MODEL}
In this section, we first give some basic concepts of mobile service composition, then introduce the concept of mobile service availability, finally we propose a specific QoS model for mobile service composition over opportunistic network.
\subsection{Preliminaries}
In order to describe the problem addressed in this paper, we first provide the basic concepts of mobile service composition.

\textit{Definition 1 (Mobile Service):} A mobile service can be represented as a three-triple $ms = (id, info, QoS)$, where:

​1) $id$ is the unique identifier of the service;

2) $info$ is the description of a mobile service which include service name, functionality, parameters and result.

​3) $QoS = \{ q_{rt}, q_{price}, q_{ava}, ... \}$ is a set of quality attributes, including response time, price, availability, etc.

\textit{Definition 2 (MSON participant):} A MSON participant is mobile service user who can be both service provider and requesters, it can be represented by a three-tuple $u = (id, P, C)$, where:

​1) $id$ is the unique identifier of a MSON participant;

​2) $P$ is the set of mobile services exposed by mobile service user $u$.

​3) $C$ is the set of discovered mobile services from nearby mobile service providers.

\textit{Definition 3 (Mobile Service Composition Plan):} A service composition plan is a tuple $mscp = (T, R)$, where:

​1) $T = \{t_1,t_2,...,t_n\}$ is a set of tasks;

​2) $R = \{d(t_i,t_j)|t_i,t_j \in T\}$ is a set of relations between tasks in $T$.

​A service composition plan is an abstract description of a business process. Each task $t_i$ can be realized by invoking an individual service. $R$ is used to describe the structure of the composition. $d(t_i, t_j) = 1$ represents that the inputs of $t_j$ depend on the outputs of $t_i$.

\textit{Definition 4 (composite service instance):} A service composition instance is a tuple $CSI = (mscp, S)$, where:

​1) $mscp$ is mobile service composition plan which defined in definition 3;

​2) $S = \{s_1, s_2,...,s_n\}$ is a set of selected concrete services.

\subsection{Concept of Mobile Service Availability}
In MSON the availability of mobile service is highly related to the user’s mobility. If user $j$ moves outside the transmission range of its neighbouring user $i$, then user $j$ is unreachable by user $i$ and as a result the services on user $j$ become unavailable to user $i$ either. Here user mobility is utilized to calculate the mobile service availability \cite{Yang2010}.

\textit{Definition 5 (Mobile Service Availability):} mobile service availability can be represented by a three-tuple $(r, p, ava) $, where

​1) $r$ is the mobile service requester;

​2) $p$ is the mobile service provider;

​3) $ava$ is the mobile service availability value between requester and provider, $ava \in [0,1)$, and $ava=0$ means service provider moves out of transmission range.


\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./img/pic3.pdf}
\caption{Mobile service availability}
\label{fig_sd}
\end{figure}

As illustrated in Fig.3, there are two mobile user $i$ and $j$, assume user $i$ is mobile service requester and user $j$ is mobile service provider, both device have the same transmission range $R$. Each user moves randomly and it is assumed that the moving field is a circle with a radius of $r$. $d$ is the distance between $i$ and $j$. We use these three parameters($r,R,d$) to calculate the availability of a mobile service. The transmission range of a node $R$ is known (e.g., usually 10m for bluetooth, 25m for Wi-Fi). 

Note that most of wireless transaction protocol have defined the Received Signal Strength Indicator, then distance $d$ between mobile user $i$ and user $j$ can be calculated by signal strength, Finally let us discuss how to calculate $r$ \cite{Yang2010}.

%Suppose that the location of each mobile user is known (e.g., via GPS data or other location-based services provided by telecommunications service providers \cite{chadil2008real}), then distance $d$ can be calculated using the Euclidean distance formula, i.e.,$\sqrt{{(x_i-x_j)^2}+({y_i-y_j})^2}$ where $(x_i, x_j)$ and $(y_i, y_j)$ are the coordinates of user $i$ and $j$ respectively. 

The moving radius of a mobile user $r$ is its moving speed $v$ multiplied by the average service time $t$. Here $t$ can be statistically calculated as the average value of last $n$ times of service invoke, namely, $t = \Sigma_{i=1}^{n}t_i/n$. The speed of a mobile user $v$ can be calculated based on its moving distance during a period from $t_1$ to $t_2$ \cite{ko2000location}, namely: $v = \sqrt{{(x_i-x_j)^2}+{y_i-y_j}^2}/(t_2-t_1)$, then $r = s \times t$.

​Once we know these three parameters $R$, $r$, and $d$, the probability of user $j$ staying inside the transmission range of user $i$ (denoted as $P_{i \ni j}$ ) can be calculated by
\begin{equation}
P_{i \ni j} = \frac{S_{i \bigcap j}}{S_j}
\end{equation}
Namely, $P_{i \ni j}$ equals to the area of the user $j$ moving field inside the transmission range of user $i$ (denoted as $S_{i \bigcap j}$) divided by the overall area of the user $j$ moving field ($S_j$) .
\begin{eqnarray}
\alpha = arccos(\frac{r^2+d^2-R^2}{2r\times d}) \\\nonumber
\beta = arccos(\frac{R^2+d^2-r^2}{2R\times d})
\end{eqnarray}
Then,
\setlength{\arraycolsep}{0.0em}
\begin{eqnarray}
S_{i \bigcap j}&{}={} & [(\frac{2\alpha}{2\pi} \times \pi r^2)-(\frac{r sin\alpha cos\alpha}{2} \times 2)]\\\nonumber
&&+[(\frac{2\beta}{2\pi} \times \pi R^2)-(\frac{R sin\beta cos\beta}{2} \times 2)]\\\nonumber
&&= \alpha r^2 + \beta R^2 - (r^2 sin\alpha cos\alpha + R^2 sin\beta cos\beta)
\end{eqnarray}
\setlength{\arraycolsep}{5pt}
There is also
\begin{equation}
S_j = \pi r^2 = \pi \times (s \times t)^2
\end{equation}
Therefore, the probability of user $j$ staying inside the transmission range of user $i$, $(P_{i \ni j})$, can be calculated as follow
\begin{equation}
P_{i \ni j} = \frac{S_{i \bigcap j}}{\pi s^2 t^2}
\end{equation}
Suppose a mobile service $s$ running on $j$ is a candidate service for a task requested by user $i$, and the availability of candidate service $s$ can be denoted as $q_{ava}(s)$, that is
\begin{eqnarray}
q_{ava}(s) &{} = {}& P_{i \ni j} \\\nonumber
&& = \frac{S_{i \bigcap j}}{\pi s^2 t^2}\\\nonumber
&& = \frac{\alpha r^2 + \beta R^2 - (r^2 sin\alpha cos\alpha + R^2 sin\beta cos\beta)}{\pi s^2 t^2}
\end{eqnarray}
Mobile service availability $q_{ava}(s)$ can capture user's mobile behavior, and we use it as an important QoS attribute to construct QoS model for service composition in next subsection.

\subsection{QoS Model for Mobile Service Composition}
For mobile service requesters to select candidate service, QoS must be considered \cite{wu2013predicting,luo2014efficient,luo2016generating}. Generally, QoS attributes include response time, price, reliability, and reputation, we introduce mobile service availability as an important QoS attribute in this paper to describe user's mobility behavior. QoS attributes in this paper can be classified into two categories: positive ($Q^+$) and negative ($Q^{-}$). For positive attributes, larger values indicate better performance (e.g., reputation and availability), while for negative attributes, smaller values indicate better performance (e.g., response time and cost) \cite{Wu2016}.	

\begin{table}[!t]
\renewcommand{\arraystretch}{1.3}
\caption{EXAMPLES OF AGGREGATION FUNCTIONS FOR QOS}
\label{table_example}
\centering
\begin{tabular}{ccc}
\hline
\bfseries Pattern & \bfseries Resopnse Time & \bfseries Availability \\
\hline
sequence & $\sum_{i=1}^{n}q_{rt}(S_i)$ & $\sum_{i=1}^{n}q_{ava}(S_i)$ \\
parallel & $Max\{q_{rt}(S_i)\}$ & $\sum_{i=1}^{n}q_{ava}(S_i)$ \\
choice & $\sum_{j=1}^{n} p_j \times q_{rt}(S_j)$ & $\sum_{j=1}^{n} p_j \times q_{ava}(S_j)$ \\
loop & $k \times q_{rt}(S_i)$ & $k \times q_{ava}(S_i)$ \\
\hline
\end{tabular}
\end{table}

For a composite service instance $CSI$, its each QoS attribute is determined by its concrete components and orchestration patterns. Table.1 lists the aggregation functions for response time, cost, and availability for sequential, loop, choice, and parallel composition patterns. We can find more aggregation functions found in \cite{jaeger2004qos} and \cite{zheng2013qos}.

In order to facilitate ranking of different composite service instances $CSI$ in terms of QoS, we utilize simple additive weighting (SAW) as the QoS utility function to map the QoS value into a real value. SAW first normalizes the QoS attribute values into real values between $0$ and $1$, through comparison with the maximal and minimal values; then it sums the normalized values multiplied with a preference weight $w_t$. According to SAW, the QoS utility of a $CSI$ can be calculated using e.q (7), where, $q_t(CSI)$ is the aggregated value of the $t$-th QoS attribute of $CSI$, and $q_{t,max}$ and $q_{t,min}$, respectively, denote the maximal and minimal possible aggregated values of the $t$-th QoS attribute \cite{Wu2016}.
\begin{eqnarray}
U(CSI) = (\sum_{q_t \in Q^-} \frac{q_{t,max}-q_t(CSI)}{q_{t,max}-q_{t,min}})\times w_t \\\nonumber
+(\sum_{q_t \in Q^+} \frac{q_t(CSI)-q_{t,min}}{q_{t,max}-q_{t,min}})\times w_t
\end{eqnarray}

\subsection{Problem Formulation}
Base on the above discussion, we can give the definition of the service composition over MSON problem.

\textit{Definition 6 (MSON Service Composition):} Given a service composition request $req$ by a mobile user $u$, perceive nearby service and select suitable concrete services to achieve an optimal service composition instance $CSI$ with the best QoS, that is
\begin{eqnarray}
target \ : \  Max \ \{U(CSI)\}   \\\nonumber
s.t. : \ t_i \in \{1,2,3,...,n\}  \\\nonumber
s_i \in \{1,2,3,...,m \}
\end{eqnarray}
where $U(CSI)$ is the objection mentioned in e.q (7), $t_i \in [1,n]$ is the index of the tasks in the composition plan, $s_i \in [1, m]$ is the index of service candidates for the $i$-th task.

\textit{Theorem 1:} The service composition problem over MSON (Definition 6) is NP-hard.

\textit{Proof:} We can reduce the service composition problem over MSON problem to a knapsack problem, and this problem can be solved by integer programming. 
The canonical form of integer linear program to search the biggest value of given objective function $F(x)$ can be expressed as follow \cite{papadimitriou1998combinatorial}:

\begin{eqnarray}
maximize \  : F(x) = c^{T}x     \\\nonumber
subject \ to: Ax \le b, \\\nonumber
x_i \in \mathbb{Z}^{n} \\\nonumber
x_i > 0 
\end{eqnarray}
Where $n$ is a positive integer, $b$ and $c$ are vectors, $A$ is a matrix.
%matrix $A$ and vector $b$ construct the constrain of service candidates bounds, vector $c$ means how to map the feasible solution $x$ to objective value.
For the problem of selecting optimal services composition over MSON, the vector $x = (x_1, . . . , x_n)$ can describe a possible solution as a service composition with $n$ tasks. An element $x_i$ in corresponds to a selected service from the candidates for the $i$-th task.
The optimal solution  $x^*$ satisfies the following conditions:

1) $x^*$ belongs to the feasible set.

​2) $\forall x, F(x^*) \le F(x)$. 

The target of the mobile service composition problem in MSON is to find the biggest $F(x)$. Thus, the problem is equivalent to the integer programming problem which is known to be NP-hard. Then the service composition problem over MSON is NP-hard.

\section{The ikh algorithm for mobile service composition}
For the problem we formulate above, integer programming can be utilized to obtain the optimal solution. However, integer programming might cost much more time with the increment of problem size because of its poor scalability \cite{nemhauser1988integer}. To solve this problem in polynomial time, an meta-heuristic algorithms such as GAs and PSO, can be utilized to find the near optimal solution.
%In this section, we will illustrate our algorithm for making mobile service compositions over MSON based on the Krill-Herd algorithm.

KH algorithm \cite{gandomi2012krill} is new generic stochastic optimization approach for the global optimization problem which is inspired by predatory behavior and communication behavior of krill. 
In this section, we will introduce a Krill-Herd based algorithm which named SKH to solve the mobile service composition over MSON problem.

\subsection{Encoding}

\begin{figure}[!t]
\centering
\includegraphics[width=3in]{./img/pic4.pdf}
\caption{Krill encoding}
\label{fig_opportunistic}
\end{figure}

%In this paper, the position vector of each krill individual corresponds to a feasible mobile service composition,
In SKH, a concrete service composition is encoded as a krill individual, the krill individual with the best position corresponds to the optimal mobile service composition. The KH optimization's target is to find the krill individual with the best position, which means to find the best mobile service composition with the best QoS Utility. Therefore, once the optimal krill individual is found, the best mobile service composition is obtained.

In this paper, the position vector of each krill individual is represented by an integer array with its length equal to the number of involved tasks. The $i$ th entry in the array, in turn, refers to the selection result of the task $t_i$ . That is to say, given that the value of the $i$ th entry is $j$, it indicates that $ms_{ij}$ is the selected concrete service to execute $t_i$ . Figure 4 illustrates this krill encoding.



\subsection{Motion operator}
% 
% 

As shown in equation (10), in motion operator, the position of each krill individual is determined by three main factors: 1) motion influenced by other krill; 2) foraging action; and 3) physical diffusion. 
\begin{equation}
\frac{dX_i}{dt} =N_i+F_i+D_i
\end{equation}

where $X_i = (ms_{1j}, ms_{2k}, . . . , ms_{nc})$ is $i$-th composition service instance $CSI_i$, $n$ is the number of tasks in the service composition, $ms_{jx}$ is the selected candidate for the $j$-th task in solution $X_i$, where $N_i$, $F_i$, and $D_i$ denote the motion influenced by other CSI, the foraging motion, and the physical diffusion, respectively.

1) Movement induced by other krill individuals

The motion induced by other krill individuals $N_i$ means to learn from neighbor mobile service compositions. It can be formulated as follow:
\begin{equation}
N^{new}_i = N^{max}\alpha_i + \omega_n N^{old}_i
\end{equation}

where
\begin{equation}
\alpha_i = \alpha^{local}+\alpha^{target}
\end{equation}

$\alpha_i$ is the direction of the induced motion and it can be evaluated by target swarm density (target effect $\alpha^{target}$), local swarm density (local effect $\alpha^{local}$). $N^{max}$ is the maximum induced speed, $\omega_n \in [0, 1]$ the inertia weight of the induced motion, $N^{old}_{i}$ is the last induced motion influenced by other CSI.

2) Foraging Motion

Similarly, the foraging motion $F_i$ is to learn from the current optimal service composition. 
$F_i$ has two parts: the current food location and the information about the previous location. 
For the $CSI_i$, we can formulate this motion as follow:
\begin{equation}
F_i = V_f\beta_i + \omega_f F^{old}_i
\end{equation}
where
\begin{equation}
\beta_i = \beta_i^{food}+\beta_i^{best}
\end{equation}
where $V_f$ is the foraging speed (empirically set to $0.8$ in this paper), $\omega_f \in [0, 1]$ is the inertia weight of foraging, and $F^{old}_i$ is the last foraging motion. $\beta_i$ is the direction of the foraging motion.

3) Random diffusion

For $CSI_i$, the physical diffusion is considered to be a random process. This motion includes two components: a maximum diffusion speed and a random directional vector, it can be formulated as follows

\begin{equation}
D_i = D^{max}\delta
\end{equation}

where $D^{max}$ is the maximum diffusion speed and $\delta \in [-1, 1]$ is a random directional vector. In this paper, the maximum diffusion speed is randomly generated in $[0.2, 0.5]$. 

\subsection{Stud selection and crossover operator}

\begin{figure}[!t]
\centering
\includegraphics[width=3in]{./img/pic5.pdf}
\caption{Cross over}
\label{fig_opportunistic}
\end{figure}


The crossover operator plays an important role in Genetic algorithm for global optimization, we use this operator in KH algorithm to enhance the search capability. The crossover operator in this paper is controlled by crossover rate $C_{rate}$ which can be obtain as follow:
\begin{equation}
C_{rate} = 0.8 + 0.2 \times \frac{F_{best}-F_{i}}{F_{best}-F_{worst}}
\end{equation}

Where $C_{rate}$ is the $i$-th individual's crossover rate, $F_{i}$ is the $i$-th individual's fitness value, $F_{best}$ is the best fitness value so far, similarly, $F_{worst}$ is the worst fitness value.

Then we can use $C_{rate}$ to generate $i$-th individual's crossover vector $C_r = \{x_{1}^m,x_{2}^m,...,x_{n}^m\}$, the $j$-th component of $i$-th individual $x_{j}^{m}$ is manipulated as:

\begin{equation}
x_{j}^m=
\begin{cases}
1,& rand(0,1) < C_{rate}\\
0,& other\\
\end{cases}
\end{equation}

For each individual $A$ to crossover, we randomly choose an target individual $B$ from current iteration and the characteristics from $B$ are copied to $A$ according to $C_r$, the crossover operator is shown in fig.4.

\begin{algorithm}
\caption{Crossover operation}
\label{alg1}
\begin{algorithmic}[1]

\REQUIRE Population $X$; Best fitness $F_{best}$; Worst fitness $F_{worst}$; Individual $A$ to crossover;
\STATE $C_{rate} \leftarrow$ calcCrossoverRate($A$, $F_{best}$, $F_{worst}$)

\FOR{$i=0$ \TO $taskNumber$}
\STATE $r \leftarrow rand(0,1)$
\IF{$r < C_{rate}$}
\STATE $C_r[i] \leftarrow 1$
\ELSE
\STATE $C_r[i] \leftarrow 0$
\ENDIF
\ENDFOR

\STATE $B \leftarrow randomSelect(X)$
\FOR{$i=0$ \TO $taskNumber$}
\STATE $A[i] \leftarrow A \verb'&'  (1-C_r[i]) + B \verb'&' C_r[i]$ 
\ENDFOR

\end{algorithmic}
\end{algorithm}

5) Update position

According to the three motion actions, the time-relied position from time $t$ to $\delta t$ can be formulated by the following equation:
\begin{equation}
X_i(t+\Delta t) = X_i(t) + \Delta t \frac{dX_i}{dt}
\end{equation}

where
\begin{equation}
\Delta t = C_t\sum_{j=1}^{d}(UB_j - LB_j)
\end{equation}

where $d$ is the tasks number of each $CSI$, $UB_j$ and $LB_j$ are upper and lower bounds of candidate services for the $j$-th task, respectively. $C_t$ is a constant value to scale the searching space. The  whole process of KH algorithm is shown in Algorithm 2.

\begin{algorithm}
\caption{KH algorithm}
\label{alg2}
\begin{algorithmic}[1]

\REQUIRE Lower bound of service candidates $lb$; Up bound of service candidates $ub$; Number of krill individuals $nk$; Number of max iteration $mi$

\ENSURE Individual with best fitness $CSI$

\STATE generate $nk$ feasible solutions randomly
\STATE save them in the population $X$
\STATE $X_{best} \leftarrow$ bestRank($X$)

\FOR{$i=0$ \TO $mi$}
  \STATE $X_f \leftarrow$ foodLocation($X$)
  \IF{$X_f < X_{f(previous)}$}
    \STATE $X_f \leftarrow X_{f(previous)}$
  \ENDIF
  \FOR{$j=0$ \TO $nk$}
    \STATE $d_{food} \leftarrow$ distance($X_j$ , $X_f$)
    \STATE $d_{best} \leftarrow$ distance($X_j$ , $X_{best}$)
    \algorithmiccomment Movement Induced
    \STATE // Movement Induced    
    \STATE $\alpha^{target} \leftarrow $ bestKrillEffect($X_{best}$, $d_{best}$) 
    \STATE $ds \leftarrow $ neighborDistance($X$)
    \STATE $\alpha^{local} \leftarrow $ neighborEffect($X$, $ds$)
    \STATE $N_i \leftarrow$ calcMovementInduced($\alpha^{local}$, $\alpha^{target}$)
    \STATE // Foraging Motion
    \STATE $\beta_{food} \leftarrow$ foodAttraction($X$, $d_{food}$)
    \STATE $\beta_{best} \leftarrow$ bestPsitionAttraction($X$, $d_{best}$)
    \STATE $F_i \leftarrow$ calcForagingMotion($V_f$, $\beta_{food}$, $\beta_{best}$)
    \STATE // Physical Diffusion
    \STATE $D_i \leftarrow$ physicalDiffusion($X$, $X_{best}$)
    \STATE $D_x \leftarrow$ calcMotionProcess($N_i$, $F_i$, $D_i$)
    \STATE Crossover($X$, $X_{best}$)
    \STATE UpdatePosition($X$, $D_x$)
  \ENDFOR
\ENDFOR
\RETURN bestRank($X$)

\end{algorithmic}
\end{algorithm}

\section{SIMULATION AND EVALUATION}
In this section, we first discussed the experimental environment settings, and then the improved KH-based approach for the mobile service composition algorithm (IKH) is evaluated from the perspective of optimality and scalability, respectively.
\subsection{Simulation Setting}
To evaluate the optimality and scalability of the proposed approaches, the experiment is run on a personal computer with an Intel Core i5 CPU with 2.4 GHz, 4 GB RAM, macOS and Matlab R2015b Edition.

Science we can not find available realistic datasets which involving both user D2D contact traces and quality of mobile service so far, we attempt to simulate the scenarios for mobile services provision by integrating realistic user D2D contact traces with quality of Web service datasets. 

We consider MIT Reality dataset as user D2D contact traces, where user location, Bluetooth devices in proximity, application usage, and phone status (such as charging and idle) were collected from 100 users over several months. This dataset can really reflect diverse network scenarios such as a sparse campus and dense conference.

The publicly available quality of Web service (QWS) dataset\cite{zheng2014investigating} can be used to characterize the service candidates. This dataset consists of 4500 Web services from 142 users over 64 different time slices (at 15-minute interval) and each QoS data includes two measurements (response time and throughput), for a mobile service $ms$, response time attribute is randomly selected from the QWS dataset. 

Table 2 is part of encounter data in MIT Reality dataset. We can clear see that for user $u$, there are five nearby devices within D2D transmission distance at time $t_1$. These devices can be regarded as MSON participant provisioning mobile services. Table 2 shows MSON participant and the services they exposed to nearby devices. These mobile service are random chosen from QWS dataset. Table 3 is the Cartesian product of Table 1 and Table 2, it shows how many kinds of services user can exploit at a certain time and how many candidates for each available service. For example, there are seven kinds of services available at time $t_1$ and there are three candidates for service $m_1$.

\begin{table}[!t]
\renewcommand{\arraystretch}{1.3}
\caption{User encounter data}
\label{table_example}
\centering
\begin{tabular}{|c||c|}
\hline
\bfseries Time & \bfseries Available service provider\\
% user(3).devices_names(500-505)
\hline
\hline
t1 & Rabbit, Tony, S10, BlueRadios, NORTHOLT\\
\hline
t2 & Tony, S10, Rabbit, NORTHOLT, BlueRadios\\
\hline
t3 & Rabbit, NORTHOLT, BlueRadios, S10, Tony, Henrymobile, S4 \\
\hline
t4 & Tony, NORTHOLT, BlueRadios, S10, Rabbit, S4\\
\hline
t5 & BlueRadios, S4, AliKatz, NORTHOLT, Rabbit, S25, S10\\
\hline
t6 & S25, S10, NORTHOLT, BlueRadios, Rabbit\\
\hline
... & ...\\
\hline
\end{tabular}
\end{table}

\begin{table}[!t]
\renewcommand{\arraystretch}{1.3}
\caption{Service provider information}
\label{table_example}
\centering
\begin{tabular}{|c||c|}
\hline
\bfseries Service Provider & \bfseries Exposed Service\\
% user(3).devices_names(500-505)
\hline
\hline
AliKatz     & $ms_1$, $ms_3$, $ms_7$\\
\hline 
BlueRadios  & $ms_1$, $ms_4$, $ms_6$\\
\hline
Henrymobile & $ms_2$, $ms_3$\\
\hline
NORTHOLT    & $ms_1$, $ms_2$, $ms_4$, $ms_5$ \\
\hline
Rabbit      & $ms_2$, $ms_3$\\
\hline 
S4          & $ms_1$, $ms_3$, $ms_6$\\
\hline 
S10         & $ms_1$, $ms_4$\\
\hline 
S25         & $ms_2$, $ms_5$, $ms_7$\\
\hline 
Tony        & $ms_2$, $ms_4$, $ms_5$, $ms_7$\\
\hline 
... & ...\\
\hline
\end{tabular}
\end{table}

\begin{table}[!t]
\renewcommand{\arraystretch}{1.3}
\caption{Available candidates}
\label{table_example}
\centering
\begin{tabular}{|c||c|}
\hline
\bfseries Time & \bfseries Available service\\
% user(3).devices_names(500-505)
\hline
\hline
t1     & $ms_1^{(3)}$, $ms_2^{(3)}$, $ms_3^{(1)}$, $ms_4^{(4)}$, $ms_5^{(2)}$, $ms_6^{(1)}$, $ms_7^{(1)}$\\
\hline 
t2     & $ms_1^{(3)}$, $ms_2^{(3)}$, $ms_3^{(1)}$, $ms_4^{(4)}$, $ms_5^{(2)}$, $ms_6^{(1)}$, $ms_7^{(1)}$\\
\hline
t2     & $ms_1^{(4)}$, $ms_2^{(4)}$, $ms_3^{(3)}$, $ms_4^{(4)}$, $ms_5^{(2)}$, $ms_6^{(1)}$, $ms_7^{(1)}$\\
\hline
t4     & $ms_1^{(4)}$, $ms_2^{(3)}$, $ms_3^{(2)}$, $ms_4^{(4)}$, $ms_5^{(2)}$, $ms_6^{(2)}$, $ms_7^{(1)}$\\
\hline
t5     & $ms_1^{(5)}$, $ms_2^{(2)}$, $ms_3^{(3)}$, $ms_4^{(3)}$, $ms_5^{(2)}$, $ms_6^{(2)}$, $ms_7^{(2)}$\\
\hline 
t6     & $ms_1^{(3)}$, $ms_2^{(3)}$, $ms_3^{(1)}$, $ms_4^{(3)}$, $ms_5^{(2)}$, $ms_6^{(1)}$, $ms_7^{(1)}$\\
\hline 
... & ...\\
\hline
\end{tabular}
\end{table}


\subsection{Impact of Parameters}
There are four parameters can be adjusted to improve the KHMSC's performance: population size $PS$, maximum iteration number $MI$, foraging speed $V_f$ and maximum induced speed $N_max$. As shown in Table 2, we generate five groups of parameters configuration to evaluate the impact of each parameter. For each group of parameters configuration, we tune one parameter and fix the other parameters. For each configuration setting, the KHMSC algorithm is executed 50 times independently and the average performance was recorded.

\begin{table}[!t]
\renewcommand{\arraystretch}{1.3}
\caption{PARAMETERS CONFIGURATION}
\label{table_example}
\centering
\begin{tabular}{cccccc}
\hline
\bfseries $PS$ & \bfseries $MI$ & \bfseries $CR$ & \bfseries $V_f$ & \bfseries $N_{max}$ & \bfseries $D_{max}$ \\
\hline
1$\sim$60 & 50          & 0.6            & 0.8            &  0.3            &  0.2 \\
20        & 10$\sim$150 & 0.6            & 0.8            &  0.3            &  0.2 \\
20        & 50          & 0.01$\sim$1.00 & 0.8            &  0.3            &  0.2 \\
20        & 50          & 0.6            & 0.01$\sim$3.00 &  0.3            &  0.2 \\
20        & 50          & 0.6            & 0.01           &  0.01$\sim$2.00 &  0.2 \\
20        & 50          & 0.6            & 0.01           &  0.3            &  0.01$\sim$3.00 \\
\hline
\end{tabular}
\end{table}

Figure 5 shows the results of tuning different parameters for KHMSC. 

Figure 5(a) shows the impact of population size, we observe that with the increase of population size, the average QoS Utility of IKH significantly improved before $PS=10$, and no significant improvement is observed after population size over $20$. Therefore, an excessively large population size e.g. $PS=50$ has limited impact on the performance of IKH, and it will result in computing resources waste and high time cost.
Similarly, Figure 5(b) shows that the value of QoS Utility significantly increased for higher number of iteration times until to a limit: $MI = 60$. Figure 5(c) shows the impact of the foraging speed $V_f$. The performance of KHMSC increases with $V_f$ and the best performance is achieved for $V_f = 0.8$. Figure 5(d) shows the impact of the induced speed $N_max$. It shows that fitness value is continually increased until to a limit: $N_max$ = 0.4 and then it decreases . 

\begin{figure*}[!t]
\centering
\subfloat[]{
\includegraphics[width=2in]{./img/Param-PS.pdf} 
\label{PS}}
\hfil
\subfloat[]{
\includegraphics[width=2in]{./img/Param-MI.pdf} 
\label{MI}}
\hfil
\subfloat[]{
\includegraphics[width=2in]{./img/Param-CR.pdf} 
\label{CR}}


\subfloat[]{
\includegraphics[width=2in]{./img/Param-Vf.pdf} 
\label{Vf}}
\hfil
\subfloat[]{
\includegraphics[width=2in]{./img/Param-Nmax.pdf} 
\label{Nmax}}
\hfil
\subfloat[]{
\includegraphics[width=2in]{./img/Param-Dmax.pdf} 
\label{Dmax}}

\caption{Impact of parameters.} \label{fig_sim}
\end{figure*}


\subsection{Optimality Evaluation}
To verify the the capability of finding the optimal mobile service composition of our algorithms, we compare KHMSC with the basic GA algorithm, basic PSO algorithm and a brute-force algorithm.

\textbf{Algorithm 1:} KH-based mobile service composition algorithm (KHMSC) which described in Section 4.

\textbf{Algorithm 2:} A basic GA which uses two-point crossover and uniform mutation.

\textbf{Algorithm 3:} A basic PSO.

\textbf{Algorithm 4:} A brute-force algorithm that traverses all feasible composition to find the optimal solution.

To evaluate the optimality of above algorithms, we tune the parameters of each algorithm to achieve its best performance. The most suitable parameters are shown in Table 3.

\begin{table}[!t]
\renewcommand{\arraystretch}{1.3}
\caption{PARAMETER SETTING OF DIFFERENT ALGORITHMS}
\label{table_example}
\centering
\begin{tabular}{cc}
\hline
\bfseries Algorithms & \bfseries Parameter Setting \\
\hline
GA  & crossover rate = 0.7; mutate rate = 0.3 \\
PSO & inertia weight = 0.8; c1 = 2.0; c2 = 2.0 \\
\hline
\end{tabular}
\end{table}

\begin{figure*}[!t]
\centering
\subfloat[]{
\includegraphics[width=2in]{./img/Opt-Iterations.pdf} 
\label{PS}}
\hfil
\subfloat[]{
\includegraphics[width=2in]{./img/Opt-Candidates.pdf} 
\label{MI}}
\hfil
\subfloat[]{
\includegraphics[width=2in]{./img/Opt-Tasks.pdf} 
\label{CR}}

\caption{Optimality evaluation.} \label{fig_sim}
\end{figure*}




The result in Figure 6 shows that, as expected, the brute-force algorithm leads to the best performance with the highest fitness. The basic PSO algorithm has the worst performance with the lowest fitness values. Both KHMSC and Ga can find over 90\% optimal composition before 50 iterations and KHMSC performs little better than the basic GA algorithm. Although GA performs closely to KHMSC, we finally choose KHMSC because it runs almost five times faster than GA, in next subsection we will evaluate the scalability of above four algorithms.

\subsection{Scalability Evaluation}
In this experiment, we compared the run time of KHMSC with the other algorithms to evaluate the scalability of our algorithm.

\begin{figure*}[!t]
\centering
\subfloat[Case I]{
\includegraphics[width=3in]{./img/Sca-Tasks.pdf} 
\label{Tasks}}
\hfil
\subfloat[Case II]{
\includegraphics[width=3in]{./img/Sca-Candidates.pdf} 
\label{Candidates}}

\caption{Scalability evaluation.} \label{fig_sim}
\end{figure*}

In order to evaluate the impact of task number on the execution time of our algorithm, The task number is varied from 6 to 30. For each task number, the simulation is repeated 50 times, and the average value is recorded as the result. We observe from figure 7(b) that the run time of brute-force method is almost exponential to the problem size, while the run time of other three meta-heuristic algorithms (KHMSC, GA, PSO) are increases almost linearly with tasks increasing. In mobile environment, due to the dynamic movement and limited of computing resources, algorithm must meet the requirement of finding feasible composition within a short time. Therefore, although brute-force can obtain the optimal result, it is not suitable to the problem due to its poor scalability. 

We also evaluate the impact of candidate services per task, In this experiment, we vary candidate service number from 6 to 30. As shown in figure 7(b), the number of candidate services does not affect the execution time of the three meta-heuristic algorithms, because in the initialization step, the scale of the algorithm is determined, and it is only affected by the algorithm parameters. Similarly, brute-force method is also exponential to the problem size. 

Among all the algorithms, PSO has the lowest run time, then KHMSC and then GA, note that KHMSC runs almost five times faster than GA, but PSO's poor optimality makes it unsuitable for this problem. Based on the experimental results, we can conclude that KHMSC maintains acceptable performance (optimality and scalability) with large data sets for both tasks and candidates.

\section{RELATED WORK}
Service-oriented computing(SOC) is a novel paradigm to develop and integrate enterprise information system \cite{}, with the development of mobile device and communication technology, the research of mobile service composition has grain much attention from both industry and academia. In this section, we first briefly review some recent work on mobile service composition, then review opportunistic network and its application in mobile network.

\subsection{mobile service composition}
Mobile service computing is the combination of service computing and mobile computing, With the development of mobile device and application industry, more and more study have emerged to address the problem of mobile service composition. 
Deng et al. \cite{Deng2016} presented an detailed introduction to mobile service computing, they first discussed the limitations of mobile computing, then classify mobile service computing into three categories: C2M, M2M, Hybrid. They also discussed the challenge toward mobile service provision and mobile service consumption in terms of performance, energy and security perspective. At their \cite{Deng2017} work, they proposed a mobile service sharing community to address the problem of service provision in mobile environment. They extent the random way point(RWP) model to capture user mobility and utilize the Krill-Herd (KH) algorithm to solve the service composition problem. Yang et al. \cite{Yang2010} presented a comprehensive QoS model specifically for pervasive services. They considered not only mobile wireless network characteristics but also user-perceived factors, and devised a corresponding formula to calculate the QoS criterion. 
zhang et al. \cite{Zhang2016} gives a context-aware service selection algorithm based on Genetic Algorithm to solve the problem of mobile service selection, they introduce a tree-encoding method to improve the capacity and efficiency of GA. However, this work did not consider user mobility.
Wang et al. \cite{wang2011exploiting} solve the problem of dependable service composition in wireless mobile ad hoc networks by taking the mobility prediction of the service providers into consideration.
They use a probability-free model and a probabilistic model to characterize the uncertainty to compose a service that can tolerate the uncertain mobility of service provider. However, this work only focus on the case of sequential service workflows and the heuristic algorithms they presented does not seek the optimal QoS service compositions.

\subsection{mobile opportunistic network}
Opportunistic networking is one of the most interesting evolutions of the multi-hop networking paradigm. Instead of constructing "stable" end-to-end paths as in the Internet, opportunistic networks do not consider node mobility a problem but as an opportunity to exploit. 
Marco et al. \cite{Conti2014} give a review of opportunistic network and regarded it as the first step in people-centric networking, they also discuss the focused research problem such as mobility model and routing problem.
Turkes et al. \cite{turkes2016cocoon} proposed a middleware named Cocoon to support mobile opportunistic network, they design a routing protocol above Wi-Fi and Bluetooth standards, their experiments which use real-world data setups show that Cocoon performs well on the aspects of dissemination rate, delivery latency and energy consumption.
Fortuna et al. \cite{fortuna2009dynamic} presented an review of dynamic service composition over both wired and wireless environment, However, their work does not present any technical details to describe how to composite service in mobile networks.
Giordano et al. \cite{Giordano2011} proposed a novel paradigm that utilize Opportunistic computing as an appealing complement to the mobile computing cloud, in this way, mobile device can combine and exploit heterogeneous resources from other devices.
Pu et al. \cite{Pu2017} presented QoS-oriented self-organized mobile crowdsourcing framework, in this work, the prevalent and sufficient characteristics of opportunistic user encounters in our daily life are utilized to solve crowdsourcing problem.
\section{CONCLUSIONS AND FURTHER STUDIES}
In this work, we propose a comprehensive framework for optimal mobile service compositing on mobile environment. We present a mobile service opportunistic network model(MSON) that fully integrates human mobility behavior factors for mobile service provisioning. Then we formulate the mobile service composition over MSON problem as an optimal problem to maximize the quality of service composition (i.e., combined QoS), propose an improved Krill-herd(IKH) algorithm to solve it, and a case study based on real-world opportunistic network and some well-known web service dataset show that our proposed approach outperforms current standard composition methods in mobile environments.

We plan to consider the following topics for future work: 1) Some prediction methods (e.g., hidden Markov model and neural networks) can be used to predict user future's movement to formulate a better mobile model; 2) more QoS metrics, e.g., service price and service reputation are supposed to be analyzed and blends into our QoS model; 3) this work doesn't consider Service-Level-Agreement(SLA) constrains. We intend to consider SLA constraints and introduce corresponding algorithms to generate run-time composition.

​		
​	



\bibliography{mybibtex}
\bibliographystyle{IEEEtran}

\end{document}






